<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Happy New Year - Magic Letter</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Playfair+Display:ital,wght@1,600;1,900&display=swap" rel="stylesheet">

  <style>
    body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; }
    #canvas-container { width: 100%; height: 100vh; display: block; }

    /* UI LAYER */
    #ui-layer {
      position: absolute; bottom: 30px; width: 100%;
      text-align: center; pointer-events: none; z-index: 100;
    }

    .guide {
      color: rgba(255, 255, 255, 0.9);
      font-size: 15px;
      margin-bottom: 20px;
      text-shadow: 0 2px 4px black;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 25px;
      border-radius: 50px;
      display: inline-block;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 215, 0, 0.3);
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
    }

    button {
      pointer-events: auto; cursor: pointer;
      background: linear-gradient(to bottom, #D32F2F, #8B0000);
      color: #FFF; border: 2px solid #FFD700;
      padding: 15px 50px; border-radius: 30px;
      font-weight: 800; font-size: 16px;
      box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

    #camera-preview {
      position: absolute; top: 15px; right: 15px;
      width: 120px; height: 90px;
      border: 2px solid rgba(255,0,0,0.5);
      transform: scaleX(-1); opacity: 0.6; border-radius: 8px;
      background: #000;
      z-index: 130;
    }

    #copyright {
      position: absolute; bottom: 10px; right: 15px;
      color: rgba(255, 255, 255, 0.3); font-size: 12px;
      z-index: 100; pointer-events: none; font-style: italic;
    }

    /* --- TEXT GI·ªÆA: "Send Di·ªáu Linh" --- */
    #center-send{
      position: absolute;
      top: 45%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 120;
      pointer-events: none;
      text-align: center;

      font-family: 'Playfair Display', serif;
      font-style: italic;
      font-weight: 900;
      font-size: clamp(34px, 6vw, 78px);
      letter-spacing: 2px;

      background: linear-gradient(90deg, #FFD700, #FF69B4, #FFD700);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;

      text-shadow:
        0 0 12px rgba(255, 215, 0, 0.35),
        0 0 22px rgba(255, 105, 180, 0.28),
        0 2px 10px rgba(0, 0, 0, 0.65);

      animation: sendFloat 3.2s ease-in-out infinite, sendGlow 2.2s ease-in-out infinite;
    }
    #center-send::after{
      content: "";
      position: absolute;
      inset: -10px -40px;
      background: linear-gradient(110deg,
        rgba(255,255,255,0) 0%,
        rgba(255,255,255,0.35) 45%,
        rgba(255,255,255,0) 70%);
      transform: translateX(-60%);
      filter: blur(2px);
      animation: sendShimmer 2.6s ease-in-out infinite;
      mix-blend-mode: screen;
    }
    @keyframes sendFloat{
      0%,100%{ transform: translate(-50%, -50%) translateY(0); }
      50%{ transform: translate(-50%, -50%) translateY(-8px); }
    }
    @keyframes sendGlow{
      0%,100%{ filter: drop-shadow(0 0 6px rgba(255,215,0,0.25)); opacity: 0.95; }
      50%{ filter: drop-shadow(0 0 14px rgba(255,105,180,0.35)); opacity: 1; }
    }
    @keyframes sendShimmer{
      0%{ transform: translateX(-60%) skewX(-10deg); opacity: 0.15; }
      50%{ transform: translateX(60%) skewX(-10deg); opacity: 0.35; }
      100%{ transform: translateX(160%) skewX(-10deg); opacity: 0.1; }
    }

    /* --- PHONG B√å --- */
    #floating-letter {
      position: absolute;
      bottom: 200px; left: 50%; margin-left: -35px;
      z-index: 200; cursor: pointer;
      animation: float 6s ease-in-out infinite;
      display: none; /* ‚úÖ ·∫®N BAN ƒê·∫¶U */
    }

    .envelope-glow {
      width: 70px; height: 50px;
      background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);
      border-radius: 8px;
      position: relative; display: flex; justify-content: center; align-items: center;
      box-shadow: 0 0 25px rgba(255, 105, 180, 0.8), 0 0 10px rgba(255, 255, 255, 0.5);
      border: 2px solid #fff; transition: transform 0.3s;
    }
    .envelope-glow::before {
      content: ''; position: absolute; top: 0; left: 0;
      border-left: 35px solid transparent; border-right: 35px solid transparent;
      border-top: 25px solid rgba(255, 255, 255, 0.6); border-bottom: 0;
    }
    .heart-seal { font-size: 24px; color: red; z-index: 2; margin-top: -5px; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2)); }
    .envelope-glow:hover { transform: scale(1.15) rotate(5deg); box-shadow: 0 0 40px rgba(255, 215, 0, 1); }
    @keyframes float { 0% { transform: translateY(0px) rotate(0deg); } 50% { transform: translateY(-20px) rotate(5deg); } 100% { transform: translateY(0px) rotate(0deg); } }

    /* --- MODAL TH∆Ø --- */
    #letter-modal {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.85); z-index: 1000;
      justify-content: center; align-items: center; backdrop-filter: blur(8px);
      padding: 16px; /* ‚úÖ tr√°nh s√°t m√©p tr√™n mobile */
      box-sizing: border-box;
    }

    /* ‚úÖ T·ªêI ∆ØU TH∆Ø D√ÄI: r·ªông h∆°n + gi·ªõi h·∫°n theo m√†n h√¨nh + cu·ªôn n·ªôi dung */
    .letter-paper{
      background: linear-gradient(to bottom, #fffdf0, #fdfbf7);
      width: min(92vw, 700px);
      max-height: min(86vh, 820px);
      padding: clamp(22px, 4vw, 46px);
      border-radius: 14px;
      position: relative;
      box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      border: 1px solid #e0d0b0;
      animation: openUp 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      text-align: center;

      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .letter-paper::after {
      content: '';
      position: absolute;
      top: 10px; left: 10px; right: 10px; bottom: 10px;
      border: 2px dashed #d4af37;
      border-radius: 5px;
      pointer-events: none;
    }

    /* ‚úÖ fade ƒë√°y ƒë·ªÉ bi·∫øt c√≤n n·ªôi dung */
    .letter-paper::before{
      content:"";
      position:absolute;
      left: 0; right: 0; bottom: 0;
      height: 45px;
      background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(253,251,247,1));
      pointer-events:none;
      z-index: 2;
    }

    @keyframes openUp {
      0% { transform: scale(0.5) translateY(100px); opacity: 0; }
      100% { transform: scale(1) translateY(0); opacity: 1; }
    }

    /* ‚úÖ N·ªôi dung cu·ªôn */
    .letter-content{
      overflow-y: auto;
      padding-right: 6px;
      flex: 1;
      -webkit-overflow-scrolling: touch;
      position: relative;
      z-index: 3;
    }

    /* scrollbar ƒë·∫πp */
    .letter-content::-webkit-scrollbar { width: 8px; }
    .letter-content::-webkit-scrollbar-thumb {
      background: rgba(212, 175, 55, 0.45);
      border-radius: 10px;
    }
    .letter-content::-webkit-scrollbar-track { background: rgba(0,0,0,0.06); }

    .letter-content h2 {
      font-family: 'Playfair Display', serif;
      color: #B22222;
      font-size: clamp(26px, 5vw, 38px);
      margin: 0 0 14px 0;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    }
    .letter-content p {
      font-family: 'Dancing Script', cursive;
      font-size: clamp(18px, 4.4vw, 26px);
      color: #4a4a4a;
      line-height: 1.85;
      margin-bottom: 14px;
    }

    .close-btn {
      position: absolute;
      top: 12px; right: 14px;
      font-size: 35px;
      color: #8B0000;
      cursor: pointer;
      font-weight: bold;
      line-height: 20px;
      transition: transform 0.2s;
      z-index: 10;
      user-select: none;
    }
    .close-btn:hover { transform: rotate(90deg) scale(1.2); color: red; }

    /* ===== PASSWORD MODAL ===== */
    #pwd-modal{
      display:none;
      position: fixed;
      inset: 0;
      z-index: 2500;
      background: rgba(0,0,0,0.78);
      backdrop-filter: blur(10px);
      justify-content: center;
      align-items: center;
      padding: 16px;
      box-sizing: border-box;
    }

    .pwd-card{
      width: min(92vw, 420px);
      background: linear-gradient(180deg, rgba(30,30,30,0.9), rgba(10,10,10,0.88));
      border: 1px solid rgba(255,215,0,0.25);
      border-radius: 18px;
      box-shadow: 0 25px 80px rgba(0,0,0,0.7), 0 0 35px rgba(255,105,180,0.12);
      padding: 22px 20px 18px;
      position: relative;
      overflow: hidden;
    }
    .pwd-card::before{
      content:"";
      position:absolute;
      inset:-60px;
      background: radial-gradient(circle at 20% 30%, rgba(255,105,180,0.18), transparent 55%),
                radial-gradient(circle at 80% 70%, rgba(255,215,0,0.18), transparent 55%);
      filter: blur(10px);
      pointer-events:none;
    }

    .pwd-title{
      position: relative;
      z-index: 2;
      font-family: "Playfair Display", serif;
      font-weight: 900;
      font-style: italic;
      font-size: 26px;
      margin: 0 0 6px 0;
      background: linear-gradient(90deg, #FFD700, #FF69B4, #FFD700);
      -webkit-background-clip: text;
      background-clip:text;
      color: transparent;
      text-align:center;
      text-shadow: 0 0 18px rgba(255,215,0,0.18);
    }

    .pwd-sub{
      position: relative;
      z-index: 2;
      margin: 0 0 14px 0;
      text-align:center;
      color: rgba(255,255,255,0.75);
      font-size: 13px;
    }

    .pwd-row{
      position: relative;
      z-index: 2;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
    }

    .pwd-input{
      width: 100%;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 12px;
      padding: 12px 14px;
      color: #fff;
      outline: none;
      font-size: 15px;
      letter-spacing: 0.5px;
      box-shadow: inset 0 0 0 1px rgba(255,215,0,0.08);
    }

    .pwd-input:focus{
      border-color: rgba(255,215,0,0.45);
      box-shadow: 0 0 0 4px rgba(255,215,0,0.12), inset 0 0 0 1px rgba(255,105,180,0.12);
    }

    .pwd-actions{
      position: relative;
      z-index: 2;
      display:flex;
      gap:10px;
      margin-top: 12px;
    }

    .pwd-btn{
      flex:1;
      pointer-events:auto;
      cursor:pointer;
      border-radius: 14px;
      padding: 12px 14px;
      font-weight: 800;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.85);
      transition: transform .15s ease, background .2s ease, border-color .2s ease;
    }

    .pwd-btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,0.09); }

    .pwd-btn.primary{
      border: 2px solid rgba(255,215,0,0.75);
      background: linear-gradient(to bottom, #D32F2F, #8B0000);
      color: #fff;
      box-shadow: 0 0 20px rgba(255,0,0,0.35);
    }

    .pwd-error{
      position: relative;
      z-index: 2;
      margin-top: 10px;
      min-height: 18px;
      text-align:center;
      font-size: 13px;
      color: rgba(255,120,180,0.95);
    }

    .pwd-close{
      position:absolute;
      top:10px; right:12px;
      z-index: 3;
      width: 34px; height: 34px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.85);
      cursor:pointer;
    }

    @keyframes shake {
      0%,100%{ transform: translateX(0); }
      20%{ transform: translateX(-8px); }
      40%{ transform: translateX(8px); }
      60%{ transform: translateX(-6px); }
      80%{ transform: translateX(6px); }
    }
    .pwd-card.shake{ animation: shake .35s ease; }
  </style>
</head>

<body>

  <!-- ‚úÖ Text gi·ªØa m√†n 1 -->
  <div id="center-send">Send Di·ªáu Linh</div>

  <!-- ‚úÖ Phong b√¨ (·∫©n l√∫c ƒë·∫ßu) -->
  <div id="floating-letter" onclick="openLetter()" title="M·ªü th∆∞">
    <div class="envelope-glow">
      <div class="heart-seal">‚ù§Ô∏è</div>
    </div>
  </div>

  <!-- ‚úÖ Modal th∆∞ -->
  <div id="letter-modal">
    <div class="letter-paper">
      <span class="close-btn" onclick="closeLetter()">&times;</span>
      <div class="letter-content">
        <h2>Happy New Year!</h2>
        <p>
          G·ª≠i <b>Di·ªáu Linh</b> xinh ƒë·∫πp,<br>
          NƒÉm 2025 s·∫Øp kh√©p l·∫°i r·ªìi. Vinh ch·ªçn vi·∫øt cho Linh m·ªôt b·ª©c th∆∞,v√¨ c√≥ nh·ªØng ƒëi·ªÅu n·∫øu n√≥i tr·ª±c ti·∫øp c√≥ th·ªÉ s·∫Ω l√†m Vinh l√∫ng t√∫ng, c√≤n vi·∫øt ra th√¨ l·∫°i d·ªÖ nh·∫π nh√†ng v√† tr·ªçn v·∫πn h∆°n.
        </p>
        <p>
          Th·ªùi gian v·ª´a r·ªìi,Vinh ch∆∞a c√≥ nhi·ªÅu c∆° h·ªôi n√≥i chuy·ªán v·ªõi Linh ·ªü b√™n ngo√†i, Vinh v·∫´n c·∫£m nh·∫≠n ƒë∆∞·ª£c ·ªü Linh r·∫•t nhi·ªÅu ƒëi·ªÅu d·ªÖ m·∫øn.
          Linh l√† m·ªôt c√¥ g√°i chƒÉm ch·ªâ, h√≤a ƒë·ªìng, v√† m·ªói l·∫ßn tr√≤ chuy·ªán, gi·ªçng n√≥i nh·∫π nh√†ng d·ªÖ th∆∞∆°ng c·ªßa Linh lu√¥n l√†m Vinh th·∫•y cu·ªôc n√≥i chuy·ªán vui h∆°n,
          tho·∫£i m√°i h∆°n. C√≥ khi ch·ªâ v√†i c√¢u th√¥i c≈©ng ƒë·ªß khi·∫øn Vinh th·∫•y ng√†y ƒë√≥ d·ªãu l·∫°i. HiHi
        </p>
        <p>
          Vinh kh√¥ng vi·∫øt th∆∞ n√†y ƒë·ªÉ t·∫°o √°p l·ª±c hay khi·∫øn Linh ph·∫£i tr·∫£ l·ªùi ƒëi·ªÅu g√¨.
          Vinh ch·ªâ mu·ªën n√≥i l√†: cu·ªëi nƒÉm 2025, Vinh th·∫•y m√¨nh may m·∫Øn v√¨ c√≥ th√™m m·ªôt ng∆∞·ªùi ƒë·ªÉ b·∫Øt ƒë·∫ßu t√¨m hi·ªÉu ‚Äî ch·∫≠m r√£i th√¥i, nh∆∞ng nghi√™m t√∫c v√† ch√¢n th√†nh.
        </p>
        <p>
          N·∫øu Linh th·∫•y tho·∫£i m√°i, sang nƒÉm m·ªõi m√¨nh n√≥i chuy·ªán nhi·ªÅu h∆°n m·ªôt ch√∫t nh√©.
          Vinh mu·ªën hi·ªÉu Linh h∆°n, theo c√°ch nh·∫π nh√†ng nh·∫•t, v√† t√¥n tr·ªçng nh·ªãp c·ªßa Linh.
        </p>
        <p>
          Ch√∫c Linh b∆∞·ªõc sang nƒÉm m·ªõi th·∫≠t b√¨nh y√™n, nhi·ªÅu ni·ªÅm vui, v√† lu√¥n ƒë∆∞·ª£c y√™u th∆∞∆°ng ƒë√∫ng c√°ch.
          C·∫£m ∆°n Linh v√¨ ƒë√£ xu·∫•t hi·ªán trong m·ªôt ƒëo·∫°n cu·ªëi nƒÉm c·ªßa Vinh.
        </p>
        <p style="margin-top: 30px; color: #B22222; font-weight: bold;">
          From dvinhh with Love üå∏
        </p>
      </div>
    </div>
  </div>

  <!-- ‚úÖ UI -->
  <div id="ui-layer">
    <div class="guide">
      üñê <b>Open:</b> 2026 &nbsp;|&nbsp;
      üëê <b>Two Hands:</b> Love &nbsp;|&nbsp;
      ‚úä <b>Fist:</b> Peach Tree
    </div>
    <br/>
    <!-- ‚úÖ Start b√¢y gi·ªù m·ªü modal m·∫≠t kh·∫©u -->
    <button id="btnStart" onclick="openPwdModal()">START MAGIC</button>
  </div>

  <div id="copyright">¬© by dvinhh</div>

  <div id="canvas-container"></div>

  <!-- Video d√πng cho mediapipe -->
  <video class="input_video" playsinline muted style="display:none"></video>
  <canvas id="camera-preview" width="320" height="240"></canvas>

  <!-- ‚úÖ PASSWORD MODAL -->
  <div id="pwd-modal" onclick="backdropClosePwd(event)">
    <div class="pwd-card" id="pwd-card">
      <button class="pwd-close" onclick="closePwdModal()" aria-label="Close">‚úï</button>

      <h3 class="pwd-title">Enter Password</h3>
      <p class="pwd-sub">Nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ b·∫Øt ƒë·∫ßu ph√©p m√†u ‚ú®</p>

      <div class="pwd-row">
        <input id="pwd-input" class="pwd-input" type="password" placeholder="Password..." autocomplete="off" />
      </div>

      <div class="pwd-actions">
        <button class="pwd-btn" onclick="closePwdModal()">Cancel</button>
        <button class="pwd-btn primary" onclick="checkPasswordAndStart()">Unlock</button>
      </div>

      <div class="pwd-error" id="pwd-error"></div>
    </div>
  </div>

  <script>
    /* ====== LETTER MODAL ====== */
    function openLetter() { document.getElementById('letter-modal').style.display = 'flex'; }
    function closeLetter() { document.getElementById('letter-modal').style.display = 'none'; }

    /* ====== PASSWORD GATE ====== */
    const PASSWORD = "nguyenthidieulinh"; // üîê ƒë·ªïi m·∫≠t kh·∫©u ·ªü ƒë√¢y
    let systemStarted = false;

    function openPwdModal(){
      const modal = document.getElementById('pwd-modal');
      const input = document.getElementById('pwd-input');
      const err = document.getElementById('pwd-error');
      const card = document.getElementById('pwd-card');

      err.textContent = "";
      card.classList.remove('shake');
      modal.style.display = 'flex';

      setTimeout(() => {
        input.value = "";
        input.focus();
      }, 50);
    }

    function closePwdModal(){
      document.getElementById('pwd-modal').style.display = 'none';
    }

    function backdropClosePwd(e){
      if (e.target && e.target.id === 'pwd-modal') closePwdModal();
    }

    function checkPasswordAndStart(){
      const input = document.getElementById('pwd-input');
      const err = document.getElementById('pwd-error');
      const card = document.getElementById('pwd-card');

      if (input.value === PASSWORD){
        closePwdModal();
        startSystem();
      } else {
        err.textContent = "Sai m·∫≠t kh·∫©u r·ªìi üò¢";
        card.classList.remove('shake');
        void card.offsetWidth;
        card.classList.add('shake');
        input.select();
      }
    }

    document.addEventListener('keydown', (e) => {
      const modal = document.getElementById('pwd-modal');
      if (modal && modal.style.display === 'flex') {
        if (e.key === 'Enter') checkPasswordAndStart();
        if (e.key === 'Escape') closePwdModal();
      }
    });

    /* ====== AUDIO ====== */
    const MUSIC_URL = "./audio.mp3";
    let bgMusic = new Audio(MUSIC_URL);
    bgMusic.loop = true;
    bgMusic.volume = 1.0;

    /* ====== THREE / MEDIAPIPE ====== */
    function createCustomTexture(type) {
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      const cx = 64, cy = 64;

      if (type === 'pink_glow') {
        const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 44);
        grd.addColorStop(0, 'rgba(255,255,255,1)');
        grd.addColorStop(0.18, 'rgba(255,210,235,1)');
        grd.addColorStop(0.55, 'rgba(255,120,185,0.9)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);
      } else if (type === 'hot_pink_glow') {
        const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
        grd.addColorStop(0, 'rgba(255,235,245,1)');
        grd.addColorStop(0.25, 'rgba(255,120,200,1)');
        grd.addColorStop(0.55, 'rgba(255,60,160,0.95)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);
      } else if (type === 'blossom') {
        ctx.clearRect(0,0,128,128);
        const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 55);
        glow.addColorStop(0, 'rgba(255,255,255,0.9)');
        glow.addColorStop(0.25, 'rgba(255,210,235,0.9)');
        glow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = glow; ctx.fillRect(0,0,128,128);

        ctx.save(); ctx.translate(cx, cy);
        for (let i=0; i<5; i++) {
          ctx.rotate((Math.PI * 2) / 5);
          ctx.beginPath();
          ctx.ellipse(0, -18, 16, 26, 0, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 140, 200, 0.95)';
          ctx.shadowColor = 'rgba(255, 80, 170, 0.8)';
          ctx.shadowBlur = 18;
          ctx.fill();
        }
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255, 220, 120, 0.95)';
        ctx.fill();
        ctx.restore();
      }
      return new THREE.CanvasTexture(canvas);
    }

    const textures = {
      gold: createCustomTexture('pink_glow'),
      red: createCustomTexture('hot_pink_glow'),
      gift: createCustomTexture('blossom')
    };

    const CONFIG = {
      goldCount: 2000,
      redCount: 300,
      giftCount: 150,
      explodeRadius: 65,
      peach: {
        canopyRx: 30, canopyRy: 22, canopyRz: 26,
        canopyCenterY: 6, trunkBottomY: -34, trunkTopY: -10
      }
    };

    let scene, camera, renderer;
    let groupGold, groupRed, groupGift;
    let titleMesh, blossomTopMesh, loveMesh, trunkMesh;
    let nameBackgroundGroup;
    let state = 'TREE';
    let handX = 0.5;

    function createMatrixNameBackground() {
      const canvas = document.createElement('canvas');
      canvas.width = 1024; canvas.height = 256;
      const ctx = canvas.getContext('2d');

      ctx.font = '900 80px "Playfair Display", serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.shadowColor = "rgba(255, 255, 255, 0.8)";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "#FFFFFF";
      ctx.fillText("NGUYEN DIEU LINH", 512, 128);

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: 0.35,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
        depthWrite: false
      });

      const geometry = new THREE.PlaneGeometry(80, 20);
      nameBackgroundGroup = new THREE.Group();

      const rows = 6, cols = 8, radius = 90;

      for (let r=0; r<rows; r++) {
        const y = -40 + r * 25;
        for (let c=0; c<cols; c++) {
          const mesh = new THREE.Mesh(geometry, material);
          const angle = (c / cols) * Math.PI * 2;
          const offsetAngle = (r % 2 === 0) ? 0 : (Math.PI / cols);
          const finalAngle = angle + offsetAngle;

          const x = Math.cos(finalAngle) * radius;
          const z = Math.sin(finalAngle) * radius;

          mesh.position.set(x, y, z);
          mesh.lookAt(0, y, 0);

          nameBackgroundGroup.add(mesh);
        }
      }
      scene.add(nameBackgroundGroup);
    }

    function generateTextTargets(text, count, opts = {}) {
      const { canvasW = 1024, canvasH = 256, font = 'bold 210px "Times New Roman"', step = 3, scale = 9, yOffset = 5, zJitter = 8 } = opts;
      const c = document.createElement('canvas'); c.width = canvasW; c.height = canvasH;
      const ctx = c.getContext('2d');
      ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = font;
      ctx.fillText(text, canvasW / 2, canvasH / 2);

      const img = ctx.getImageData(0, 0, canvasW, canvasH).data;
      const pts = [];
      for (let y = 0; y < canvasH; y += step) {
        for (let x = 0; x < canvasW; x += step) {
          if (img[(y * canvasW + x) * 4 + 3] > 10) pts.push([x, y]);
        }
      }

      const out = new Float32Array(count * 3);
      if (pts.length === 0) return out;

      for (let i = 0; i < count; i++) {
        const p = pts[(Math.random() * pts.length) | 0];
        out[i * 3] = (p[0] - canvasW / 2) / scale;
        out[i * 3 + 1] = (canvasH / 2 - p[1]) / scale + yOffset;
        out[i * 3 + 2] = (Math.random() - 0.5) * zJitter;
      }
      return out;
    }

    function generatePeachCanopyTargets(type, count) {
      const out = new Float32Array(count * 3);
      const p = CONFIG.peach;

      for (let i = 0; i < count; i++) {
        const edgeBias = (type === 'gift') ? 0.75 : 0.35;
        let u = Math.random(), v = Math.random(), w = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = Math.pow(w, edgeBias);

        let x = Math.sin(phi) * Math.cos(theta) * p.canopyRx * r;
        let y = Math.cos(phi) * p.canopyRy * r + p.canopyCenterY;
        let z = Math.sin(phi) * Math.sin(theta) * p.canopyRz * r;

        x += (Math.random() - 0.5) * 2.5;
        y += (Math.random() - 0.5) * 1.8;
        z += (Math.random() - 0.5) * 2.5;

        if (type === 'gift' && Math.random() < 0.18) {
          x = (Math.random() - 0.5) * (p.canopyRx * 1.2);
          z = (Math.random() - 0.5) * (p.canopyRz * 1.2);
          y = p.trunkBottomY + 1.5 + Math.random() * 4.0;
        }

        out[i * 3] = x; out[i * 3 + 1] = y; out[i * 3 + 2] = z;
      }
      return out;
    }

    function init3D() {
      const container = document.getElementById('canvas-container');

      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.002);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 100;

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);

      groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.2);
      groupRed  = createParticleSystem('red',  CONFIG.redCount,  3.6);
      groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.2);

      createDecorations();
      createMatrixNameBackground();

      animate();
    }

    function createParticleSystem(type, count, size) {
      const pPositions = [], pExplodeTargets = [], pHeartTargets = [], sizes = [], phases = [];
      const peachTreeTargets = generatePeachCanopyTargets(type, count);

      for (let i = 0; i < count; i++) {
        const u = Math.random(), v = Math.random();
        const phi = Math.acos(2 * v - 1), lam = 2 * Math.PI * u;
        const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * ((type === 'gift') ? 1.2 : 1.0);
        pExplodeTargets.push(
          rad * Math.sin(phi) * Math.cos(lam),
          rad * Math.sin(phi) * Math.sin(lam),
          rad * Math.cos(phi)
        );

        const tHeart = Math.random() * Math.PI * 2;
        let hx = 16 * Math.pow(Math.sin(tHeart), 3);
        let hy = 13 * Math.cos(tHeart) - 5 * Math.cos(2 * tHeart) - 2 * Math.cos(3 * tHeart) - Math.cos(4 * tHeart);
        const rFill = Math.pow(Math.random(), 0.3);
        hx *= rFill; hy *= rFill;
        let hz = (Math.random() - 0.5) * 8 * rFill;
        pHeartTargets.push(hx * 2.2, hy * 2.2 + 5, hz);

        pPositions.push(
          peachTreeTargets[i * 3],
          peachTreeTargets[i * 3 + 1],
          peachTreeTargets[i * 3 + 2]
        );

        sizes.push(size);
        phases.push(Math.random() * Math.PI * 2);
      }

      const y2025 = generateTextTargets('2025', count);
      const y2026 = generateTextTargets('2026', count);

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
      geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

      const colors = new Float32Array(count * 3);
      const baseColor = new THREE.Color();
      if (type === 'gold') baseColor.setStyle('#FFC1D9');
      else if (type === 'red') baseColor.setStyle('#FF4FA3');
      else baseColor.setStyle('#FFEAF4');

      for (let i = 0; i < count; i++) {
        colors[i*3] = baseColor.r;
        colors[i*3+1] = baseColor.g;
        colors[i*3+2] = baseColor.b;
      }

      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geo.userData = {
        tree: Array.from(peachTreeTargets),
        explode: pExplodeTargets,
        heart: pHeartTargets,
        year2025: Array.from(y2025),
        year2026: Array.from(y2026),
        phases,
        baseColor,
        baseSize: size
      };

      const mat = new THREE.PointsMaterial({
        size,
        map: textures[type],
        transparent: true,
        opacity: 1.0,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        sizeAttenuation: true
      });

      const points = new THREE.Points(geo, mat);
      scene.add(points);
      return points;
    }

    function createDecorations() {
      const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 256;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createLinearGradient(0, 0, 1024, 0);
      gradient.addColorStop(0, '#FFD700');
      gradient.addColorStop(0.5, '#FF1493');
      gradient.addColorStop(1, '#FFD700');

      ctx.font = '900 italic 90px "Times New Roman"';
      ctx.textAlign = 'center';
      ctx.shadowColor = "#FF0055";
      ctx.shadowBlur = 40;
      ctx.fillStyle = gradient;
      ctx.fillText("HAPPY NEW YEAR", 512, 130);

      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
      ctx.strokeText("HAPPY NEW YEAR", 512, 130);

      const tex = new THREE.CanvasTexture(canvas);
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, blending: THREE.AdditiveBlending });
      titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), mat);
      titleMesh.position.set(0, 52, 0);
      scene.add(titleMesh);

      const bCanvas = document.createElement('canvas'); bCanvas.width = 256; bCanvas.height = 256;
      const bCtx = bCanvas.getContext('2d'); bCtx.translate(128,128);
      for (let i=0; i<5; i++) {
        bCtx.rotate((Math.PI*2)/5);
        bCtx.beginPath();
        bCtx.ellipse(0, -42, 28, 46, 0, 0, Math.PI*2);
        bCtx.fillStyle = 'rgba(255, 140, 200, 0.95)';
        bCtx.shadowColor = 'rgba(255, 80, 170, 0.9)';
        bCtx.shadowBlur = 22;
        bCtx.fill();
      }
      bCtx.beginPath();
      bCtx.arc(0, 0, 18, 0, Math.PI*2);
      bCtx.fillStyle = 'rgba(255, 220, 120, 0.98)';
      bCtx.fill();

      const blossomTex = new THREE.CanvasTexture(bCanvas);
      const blossomMat = new THREE.MeshBasicMaterial({ map: blossomTex, transparent: true, blending: THREE.AdditiveBlending });
      blossomTopMesh = new THREE.Mesh(new THREE.PlaneGeometry(14, 14), blossomMat);
      blossomTopMesh.position.set(0, CONFIG.peach.canopyCenterY + CONFIG.peach.canopyRy + 2, 0);
      scene.add(blossomTopMesh);

      const lCanvas = document.createElement('canvas'); lCanvas.width = 1024; lCanvas.height = 256;
      const lCtx = lCanvas.getContext('2d');
      lCtx.font = 'bold 120px "Segoe UI", sans-serif';
      lCtx.fillStyle = '#FF69B4';
      lCtx.textAlign = 'center';
      lCtx.shadowColor = "#FF1493";
      lCtx.shadowBlur = 40;
      lCtx.fillText("I LOVE YOU ‚ù§Ô∏è", 512, 130);

      const loveTex = new THREE.CanvasTexture(lCanvas);
      const loveMat = new THREE.MeshBasicMaterial({ map: loveTex, transparent: true, blending: THREE.AdditiveBlending });
      loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), loveMat);
      loveMesh.position.set(0, 0, 20);
      loveMesh.visible = false;
      scene.add(loveMesh);

      const trunkCanvas = document.createElement('canvas'); trunkCanvas.width = 64; trunkCanvas.height = 256;
      const tCtx = trunkCanvas.getContext('2d');
      const grd = tCtx.createLinearGradient(0,0,64,256);
      grd.addColorStop(0, '#4A2A14');
      grd.addColorStop(1, '#3A1F10');
      tCtx.fillStyle = grd; tCtx.fillRect(0,0,64,256);

      const trunkTex = new THREE.CanvasTexture(trunkCanvas);
      const trunkMat = new THREE.MeshBasicMaterial({ map: trunkTex, transparent: true, opacity: 0.95 });
      const trunkH = (CONFIG.peach.trunkTopY - CONFIG.peach.trunkBottomY);
      trunkMesh = new THREE.Mesh(new THREE.CylinderGeometry(4.2, 6.0, Math.abs(trunkH), 18, 1, true), trunkMat);
      trunkMesh.position.set(0, (CONFIG.peach.trunkTopY + CONFIG.peach.trunkBottomY) / 2, 0);
      trunkMesh.rotation.y = 0.4;
      scene.add(trunkMesh);
    }

    function updateParticleGroup(group, type, targetState, speed, handRotY, time) {
      const positions = group.geometry.attributes.position.array;
      const colors = group.geometry.attributes.color.array;
      const phases = group.geometry.userData.phases;
      const baseColor = group.geometry.userData.baseColor;

      let targets;
      if (targetState === 'TREE') targets = group.geometry.userData.tree;
      else if (targetState === 'HEART') targets = group.geometry.userData.heart;
      else if (targetState === 'YEAR2025') targets = group.geometry.userData.year2025;
      else if (targetState === 'YEAR2026') targets = group.geometry.userData.year2026;
      else targets = group.geometry.userData.explode;

      for (let i = 0; i < positions.length; i++) {
        positions[i] += (targets[i] - positions[i]) * speed;
      }
      group.geometry.attributes.position.needsUpdate = true;

      const count = positions.length / 3;

      if (targetState === 'TREE') {
        group.rotation.y = 0.18 * Math.sin(time * 0.35);
        for (let i = 0; i < count; i++) {
          let brightness = (type === 'red')
            ? 0.65 + 0.55 * Math.sin(time * 2.6 + phases[i])
            : 0.75 + 0.35 * Math.sin(time * 3.2 + phases[i]);
          colors[i * 3]     = baseColor.r * brightness;
          colors[i * 3 + 1] = baseColor.g * brightness;
          colors[i * 3 + 2] = baseColor.b * brightness;
        }
      } else if (targetState === 'HEART') {
        group.rotation.y = 0;
        const beatScale = 1 + Math.abs(Math.sin(time * 3)) * 0.15;
        group.scale.set(beatScale, beatScale, beatScale);
        for (let i = 0; i < count; i++) {
          colors[i * 3]     = baseColor.r;
          colors[i * 3 + 1] = baseColor.g;
          colors[i * 3 + 2] = baseColor.b;
        }
      } else {
        group.scale.set(1, 1, 1);
        group.rotation.y += (handRotY - group.rotation.y) * 0.1;
        for (let i = 0; i < count; i++) {
          let brightness = 0.85 + 0.55 * Math.sin(time * 10 + phases[i]);
          colors[i * 3]     = baseColor.r * brightness;
          colors[i * 3 + 1] = baseColor.g * brightness;
          colors[i * 3 + 2] = baseColor.b * brightness;
        }
      }

      group.geometry.attributes.color.needsUpdate = true;
    }

    function animate() {
      requestAnimationFrame(animate);

      const time = Date.now() * 0.001;
      const speed = 0.08;
      const handRotY = (handX - 0.5) * 4.0;

      updateParticleGroup(groupGold, 'gold', state, speed, handRotY, time);
      updateParticleGroup(groupRed,  'red',  state, speed, handRotY, time);
      updateParticleGroup(groupGift, 'gift', state, speed, handRotY, time);

      if (nameBackgroundGroup) {
        nameBackgroundGroup.rotation.y = time * 0.05;
        const pulse = 0.3 + 0.1 * Math.sin(time * 2);
        nameBackgroundGroup.children.forEach(mesh => { mesh.material.opacity = pulse; });
      }

      if (state === 'TREE') {
        titleMesh.visible = true;
        blossomTopMesh.visible = true;
        loveMesh.visible = false;
        trunkMesh.visible = true;
        blossomTopMesh.rotation.z = 0.2 * Math.sin(time * 1.2);
      } else if (state === 'YEAR2025' || state === 'YEAR2026') {
        titleMesh.visible = true;
        blossomTopMesh.visible = false;
        loveMesh.visible = false;
        trunkMesh.visible = false;
      } else if (state === 'HEART') {
        titleMesh.visible = false;
        blossomTopMesh.visible = false;
        trunkMesh.visible = false;
        loveMesh.visible = true;
        const s = 1 + Math.abs(Math.sin(time * 3)) * 0.1;
        loveMesh.scale.set(s, s, 1);
      } else {
        titleMesh.visible = false;
        blossomTopMesh.visible = false;
        loveMesh.visible = false;
        trunkMesh.visible = false;
      }

      renderer.render(scene, camera);
    }

    async function startHandsCamera() {
      const video = document.getElementsByClassName('input_video')[0];
      const canvas = document.getElementById('camera-preview');
      const ctx = canvas.getContext('2d');

      const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });

      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      hands.onResults(results => {
        const lms = results.multiHandLandmarks || [];
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (results.image) ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

        if (lms.length === 2) { state = 'HEART'; return; }

        if (lms.length > 0) {
          const lm = lms[0];
          handX = lm[9].x;

          const tips = [8, 12, 16, 20];
          const wrist = lm[0];
          let openDist = 0;
          tips.forEach(i => openDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y));
          const avgDist = openDist / 4;

          if (avgDist < 0.25) state = 'TREE';
          else if (avgDist > 0.38) state = 'YEAR2026';
          else state = 'EXPLODE';
        } else {
          state = 'TREE';
        }
      });

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width: 320, height: 240, facingMode: "user" },
          audio: false
        });
        video.srcObject = stream;
        await video.play();

        async function loop() {
          if (video.readyState >= 2) await hands.send({ image: video });
          requestAnimationFrame(loop);
        }
        loop();

        setTimeout(() => { if (state === 'TREE') state = 'YEAR2025'; }, 1500);
        return true;
      } catch (e) {
        console.warn("Camera not available:", e);
        return false;
      }
    }

    function startSystem() {
      if (systemStarted) return;
      systemStarted = true;

      document.getElementById('btnStart').style.display = 'none';

      const cs = document.getElementById('center-send');
      if (cs) cs.style.display = 'none';

      document.getElementById('floating-letter').style.display = 'block';

      bgMusic.play().catch(e => console.log(e));
      init3D();
      startHandsCamera();
    }

    window.addEventListener('resize', () => {
      if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });
  </script>
</body>
</html>
